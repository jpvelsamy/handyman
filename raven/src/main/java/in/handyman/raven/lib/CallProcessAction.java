package in.handyman.raven.lib;

import com.zaxxer.hikari.HikariDataSource;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lambda.doa.audit.PipelineExecutionAudit;
import in.handyman.raven.lambda.process.HRequestResolver;
import in.handyman.raven.lambda.process.LContext;
import in.handyman.raven.lib.model.CallProcess;
import in.handyman.raven.util.CommonQueryUtil;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "CallProcess")
public class CallProcessAction implements IActionExecution {

    private final ActionExecutionAudit actionExecutionAudit;
    private final Logger log;
    private final CallProcess callProcess;

    private final Marker aMarker;

    public CallProcessAction(final ActionExecutionAudit actionExecutionAudit, final Logger log, final Object callProcess) {
        this.callProcess = (CallProcess) callProcess;
        this.actionExecutionAudit = actionExecutionAudit;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("CallProcess");
    }

    @Override
    public void execute() throws Exception {
        final String fileRelativePath = callProcess.getSource();
        var targetProcess = callProcess.getTarget();
        var dbSrc = callProcess.getDatasource();
        var sql = callProcess.getValue().replaceAll("\"", "");
        log.info(aMarker, " id#{}, name#{}, calledProcess#{}, calledFile#{}, db=#{}", actionExecutionAudit.getActionId(), callProcess.getName(), targetProcess, fileRelativePath, dbSrc);
        final HikariDataSource source = ResourceAccess.rdbmsConn(dbSrc);
        var runContext = new ArrayList<LContext>();
        final Map<String, String> context = actionExecutionAudit.getContext();
        try (var conn = source.getConnection()) {
            try (var stmt = conn.createStatement()) {
                try (var rs = stmt.executeQuery(sql)) {
                    var columnCount = rs.getMetaData().getColumnCount();
                    while (rs.next()) {
                        CommonQueryUtil.addKeyConfig(context, log,
                                rs, columnCount, "");
                        final LContext lContext = LContext.builder()
                                .inheritedContext(new HashMap<>(context))
                                .lambdaName(actionExecutionAudit.getLambdaName())
                                .parentActionId(actionExecutionAudit.getActionId())
                                .parentActionName(actionExecutionAudit.getActionName())
                                .relativePath(fileRelativePath)
                                .processLoadType(HRequestResolver.LoadType.FILE.name())
                                .pipelineName(callProcess.getTarget())
                                .parentPipelineId(actionExecutionAudit.getPipelineId())
                                .parentPipelineName(actionExecutionAudit.getPipelineName())
                                .rootPipelineId(actionExecutionAudit.getRootPipelineId())
                                .build();
                        runContext.add(lContext);
                    }
                }
            }
        }
        log.info(aMarker, "Completed name#{}, calledProcess#{}, calledFile#{}, db=#{}", callProcess.getName(), targetProcess, fileRelativePath, dbSrc);

        final int forkBatchSize = Optional.ofNullable(callProcess.getForkBatchSize()).map(Integer::valueOf).orElse(0);
        if (forkBatchSize != 0) {
            var executor = Executors.newWorkStealingPool(forkBatchSize);
            var counter = new CountDownLatch(runContext.size());
            runContext.forEach(lContext -> {
                final LambdaCallable lambdaCallable = new LambdaCallable(lContext, counter);
                executor.submit(lambdaCallable);
            });

            try {
                counter.await();
            } catch (InterruptedException e) {
                throw new HandymanException("Call process parallel failed ", e);
            }

        } else {
            runContext.forEach(lContext -> {
                final LambdaCallable lambdaCallable = new LambdaCallable(lContext, null);
                try {
                    final PipelineExecutionAudit start = lambdaCallable.call();
                    context.putAll(start.getContext());
                } catch (Exception e) {
                    log.trace(aMarker, "Failed process {}", lContext, e);
                }
            });
        }


    }


    @Override
    public boolean executeIf() {
        return callProcess.getCondition();
    }
}
