package in.handyman.raven.lib;

import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.ActionExecutionAudit;
import in.handyman.raven.lambda.process.HRequestResolver;
import in.handyman.raven.lambda.process.LContext;
import in.handyman.raven.lib.model.DogLeg;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = DogLegAction.DOG_LEG
)
public class DogLegAction implements IActionExecution {

    protected static final String DOG_LEG = "DogLeg";
    private final ActionExecutionAudit actionExecutionAudit;
    private final Logger log;
    private final DogLeg dogLeg;

    private final Marker aMarker;

    public DogLegAction(final ActionExecutionAudit actionExecutionAudit, final Logger log, final Object dogLeg) {
        this.dogLeg = (DogLeg) dogLeg;
        this.actionExecutionAudit = actionExecutionAudit;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(DOG_LEG);
    }

    @Override
    public void execute() throws Exception {
        var processList = dogLeg.getProcessList();
        log.info(aMarker, " id: {}, name: {} given params {}", actionExecutionAudit.getActionId(), dogLeg.getName(), dogLeg);
        var countDownLatch = new CountDownLatch(processList.size());
        var inheritContext = Objects.equals(dogLeg.getInheritContext(), "true");
        var executor = Executors.newWorkStealingPool();
        final Map<String, String> context = inheritContext ? actionExecutionAudit.getContext() : Collections.emptyMap();
        processList.forEach(startProcess -> {
            var processName = startProcess.getName();
            var fileRelativePath = startProcess.getTarget();
            final LContext lContext = LContext.builder()
                    .inheritedContext(context)
                    .lambdaName(actionExecutionAudit.getLambdaName())
                    .parentActionId(actionExecutionAudit.getActionId())
                    .parentActionName(actionExecutionAudit.getActionName())
                    .relativePath(fileRelativePath)
                    .processLoadType(HRequestResolver.LoadType.FILE.name())
                    .pipelineName(processName)
                    .parentPipelineId(actionExecutionAudit.getPipelineId())
                    .parentPipelineName(actionExecutionAudit.getPipelineName())
                    .rootPipelineId(actionExecutionAudit.getRootPipelineId())
                    .build();
            var processWorker = new LambdaCallable(lContext, countDownLatch);
            executor.submit(processWorker);
        });
        countDownLatch.await();
    }

    @Override
    public boolean executeIf() throws Exception {
        return dogLeg.getCondition();
    }
}
