package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.AssetInfo;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.OkHttpClient;
import org.apache.commons.io.FilenameUtils;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import static java.lang.Math.random;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "AssetInfo"
)
public class AssetInfoAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final AssetInfo assetInfo;

  private final Marker aMarker;

  public AssetInfoAction(final ActionExecutionAudit action, final Logger log,
                         final Object assetInfo) {
    this.assetInfo = (AssetInfo) assetInfo;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" AssetInfo:" + this.assetInfo.getName());
  }

  @Override
  public void execute() throws Exception {
    try {
      log.info(aMarker, "<-------Asset Info Action for {} has been started------->" + assetInfo.getName());
      final OkHttpClient httpclient = new OkHttpClient.Builder()
              .connectTimeout(10, TimeUnit.MINUTES)
              .writeTimeout(10, TimeUnit.MINUTES)
              .readTimeout(10, TimeUnit.MINUTES).build();
      final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(assetInfo.getResourceConn());
      final List<Map<String, Object>> tableInfos = new ArrayList<>();

      jdbi.useTransaction(handle -> {
        final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(assetInfo.getValues());
        formattedQuery.forEach(sqlToExecute -> {
          tableInfos.addAll(handle.createQuery(sqlToExecute).mapToMap().stream().collect(Collectors.toList()));
        });
      });
      List<Path> pathList = new ArrayList<>();
      for (var tableInfo : tableInfos) {
        final String tenantIdString = Optional.ofNullable(tableInfo.get("tenant_id")).map(String::valueOf).orElse("[]");
        final String templateIdString = Optional.ofNullable(tableInfo.get("template_id")).map(String::valueOf).orElse("[]");
        final String createdUserIdString = Optional.ofNullable(tableInfo.get("created_user_id")).map(String::valueOf).orElse("[]");
        final String lastUpdatedUserIdString = Optional.ofNullable(tableInfo.get("last_updated_user_id")).map(String::valueOf).orElse("[]");
        final String filePathString = Optional.ofNullable(tableInfo.get("file_path")).map(String::valueOf).orElse("[]");
        final String originIdString = Optional.ofNullable(tableInfo.get("origin_id")).map(String::valueOf).orElse("[]");

        try (var files = Files.walk(Path.of(filePathString)).filter(Files::isRegularFile)) {
          files.forEach(pathList::add);
        }
        pathList.forEach(path -> {
          File file = new File(path.toUri());
          String sha1Hex;
          try (InputStream is = Files.newInputStream(Path.of(file.getPath()))) {
            sha1Hex = org.apache.commons.codec.digest.DigestUtils.sha1Hex(is);
          } catch (IOException e) {
            throw new RuntimeException(e);
          }

          var fileSize = file.length() / 1024;
          FileInfo fileInfo = FileInfo.builder()
                  .file_checksum(sha1Hex)
                  .file_extension(FilenameUtils.getExtension(file.getName()))
                  .file_name(FilenameUtils.removeExtension(file.getName()))
                  .file_path(file.getPath())
                  .file_size(String.valueOf(fileSize))
                  .root_pipeline_id(action.getContext().get("pipeline-id"))
                  .process_id(action.getContext().get("process-id"))
                  .build();

          jdbi.useTransaction(handle -> {
            handle.createUpdate("INSERT INTO macro.file_details(process_id,root_pipeline_id, file_checksum, file_extension, file_name, file_path, file_size)" +
                            "VALUES(:process_id, :root_pipeline_id, :file_checksum, :file_extension, :file_name, :file_path, :file_size);")
                    .bindBean(fileInfo).execute();
            log.debug(aMarker, "inserted {} into source of origin", fileInfo);
          });
        });
      }


    } catch (Exception e) {
      action.getContext().put(assetInfo.getName().concat(".error"), "true");
      log.info(aMarker, "The Exception occurred ", e);
      throw new HandymanException("Failed to execute", e);
    }
    log.info(aMarker, "<-------Asset Info Action for {} has been completed------->" + assetInfo.getName());
  }

  @Override
  public boolean executeIf() throws Exception {
    return assetInfo.getCondition();
  }


  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public static class FileInfo {
    private String process_id;
    private String root_pipeline_id;
    private String file_checksum;
    private String file_extension;
    private String file_name;
    private String file_path;
    private String file_size;
  }
}