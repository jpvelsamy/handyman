package in.handyman.raven.lib;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ScalarAdapter;
import in.handyman.raven.lib.model.Validator;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.OkHttpClient;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ScalarAdapter"
)
public class ScalarAdapterAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final ScalarAdapter scalarAdapter;
    private final Marker aMarker;
    private final ObjectMapper mapper = new ObjectMapper();


    public ScalarAdapterAction(final ActionExecutionAudit action, final Logger log,
                               final Object scalarAdapter) {
        this.scalarAdapter = (ScalarAdapter) scalarAdapter;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" ScalarAdapter:" + this.scalarAdapter.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            log.info(aMarker, "scalar has started" + scalarAdapter.getName());
            final OkHttpClient httpclient = new OkHttpClient.Builder()
                    .connectTimeout(10, TimeUnit.MINUTES)
                    .writeTimeout(10, TimeUnit.MINUTES)
                    .readTimeout(10, TimeUnit.MINUTES).build();
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(scalarAdapter.getResourceConn());
            final List<ValidatorConfigurationDetail> docnutResult = new ArrayList<>();

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(scalarAdapter.getResuletSet());
                formattedQuery.forEach(sqlToExecute -> {
                    docnutResult.addAll(handle.createQuery(sqlToExecute).
                            mapToBean(ValidatorConfigurationDetail.class).stream().collect(Collectors.toList()));
                });
            });


            for (ValidatorConfigurationDetail result : docnutResult) {
                String inputValue = result.getInputValue();
                int wordScore = WordcountAction.getWordCount(inputValue,
                        result.getWordLimit(), result.getWordThreshold());
                int charScore = CharactercountAction.getCharCount(inputValue,
                        result.getCharLimit(), result.getCharThreshold());
                Validator configurationDetails = Validator.builder()
                        .inputValue(inputValue)
                        .adapter(result.getAllowedAdapter())
                        .allowedSpecialChar(result.getAllowedCharacters())
                        .comparableChar(result.getComparableCharacters())
                        .threshold(result.getValidatorThreshold())
                        .build();
                int validatorScore = getAdpterScore(configurationDetails);
                int validatorNegativeScore = 0;
                if (result.getRestrictedAdapterFlag() == 1 && validatorScore != 0) {
                    configurationDetails.setAdapter(result.getRestrictedAdapter());
                    validatorNegativeScore = getAdpterScore(configurationDetails);
                }

                double confidenceScore = wordScore + charScore + validatorScore - validatorNegativeScore;

                result.setConfidenceScore(confidenceScore);

                jdbi.useTransaction(handle -> {
                    handle.createUpdate("INSERT INTO sor_transaction.docnet_result" +
                                    "( file_ref_id, paper_no, group_id, sor_id, sor_item_id, sor_item_name, question, answer, created_user_id, tenant_id, created_on, confidence_score) " +
                                    "VALUES( :fileRefId, :paperNo, :groupId, :sorId, :sorItemId, :sorKey, :question, :inputValue, :createdUserId, :tenentId, NOW(), :confidenceScore);")
                            .bindBean(result).execute();
                    log.debug(aMarker, "inserted {} into docnet result", scalarAdapter);
                });
            }
            log.info(aMarker, "scalar has completed" + scalarAdapter.getName());
        } catch (Exception e) {
            action.getContext().put(scalarAdapter.getName().concat(".error"), "true");
            log.info(aMarker, "The Exception occurred ", e);
            throw new HandymanException("Failed to execute", e);
        }
    }


    int getAdpterScore(Validator inputDetail) {
        int confidenceScore = 0;
        switch (inputDetail.getAdapter()) {
            case "alpha":
                confidenceScore = AlphavalidatorAction.getAlphaScore(inputDetail);
                break;
            case "alphanumeric":
                confidenceScore = AlphanumericvalidatorAction.getAlphaNumericScore(inputDetail);
                break;
            case "numeric":
                confidenceScore = NumericvalidatorAction.getNumericScore(inputDetail);
                break;
            case "ner":
                String URI = action.getContext().get("copro.text-validation.url");
                confidenceScore = NervalidatorAction.getNerScore(inputDetail, URI);
                break;
            case "date":
                confidenceScore = DatevalidatorAction.getDateScore(inputDetail);
                break;
        }
        return confidenceScore;
    }

    @Override
    public boolean executeIf() throws Exception {
        return scalarAdapter.getCondition();
    }

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class ValidatorConfigurationDetail {
        private int sorId;
        private String sorKey;
        private String question;
        private String inputValue;
        private String allowedAdapter;
        private String restrictedAdapter;
        private int wordLimit;
        private int wordThreshold;
        private int charLimit;
        private int charThreshold;
        private int validatorThreshold;
        private String allowedCharacters;
        private String comparableCharacters;
        private int restrictedAdapterFlag;
        private String fileRefId;
        private int paperNo;
        private String groupId;
        private int sorItemId;
        private String createdUserId;
        private String tenentId;
        private double confidenceScore;

        private String sorItemName;
    }
}
