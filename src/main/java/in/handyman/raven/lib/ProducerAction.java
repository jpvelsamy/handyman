package in.handyman.raven.lib;

import com.fasterxml.jackson.databind.ObjectMapper;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lambda.process.LambdaEngine;
import in.handyman.raven.lib.model.Producer;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "Producer"
)
public class ProducerAction implements IActionExecution {

    private final ActionExecutionAudit actionExecutionAudit;
    private final Logger log;
    private final Producer producer;
    private final Marker aMarker;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public ProducerAction(final ActionExecutionAudit actionExecutionAudit, final Logger log, final Object producer) {
        this.producer = (Producer) producer;
        this.actionExecutionAudit = actionExecutionAudit;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" Producer:" + this.producer.getName());
    }

    @Override
    public void execute() {
        log.info(aMarker, "given {}", producer);

        log.info(aMarker, "Execution has been started in a Parallel");

        Optional.ofNullable(producer.getActions()).filter(x -> !x.isEmpty())
                .ifPresent(actionContexts -> {

                    final List<ActionCallable> collect = actionContexts.stream()
                            .map(actionContext -> {
                                var vAction = LambdaEngine.getAction(producer.getName(), actionExecutionAudit);
                                vAction.setContext(actionExecutionAudit.getContext());
                                log.info(aMarker, "Before execution Context {}", vAction.getContext());
                                return new ActionCallable(actionContext, vAction, null);
                            }).collect(Collectors.toList());
                    collect
                            .forEach(ActionCallable::run);

                    log.info(aMarker, "After execution Context {}", actionExecutionAudit.getContext());

                });

        log.info(aMarker, "Completed Execution");

    }

    public ActionExecutionAudit getAction() {
        return actionExecutionAudit;
    }

    public Producer getProducer() {
        return producer;
    }

    @Override
    public boolean executeIf() {
        return producer.getCondition();
    }
}
