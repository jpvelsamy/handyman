package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lambda.doa.audit.PipelineExecutionAudit;
import in.handyman.raven.lambda.process.HRequestResolver;
import in.handyman.raven.lambda.process.LContext;
import in.handyman.raven.lib.model.CallProcess;
import in.handyman.raven.util.CommonQueryUtil;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;

/**
 * Auto Generated By Raven
 */
@ActionExecution(actionName = "CallProcess")
public class CallProcessAction implements IActionExecution {

    private final ActionExecutionAudit actionExecutionAudit;
    private final Logger log;
    private final CallProcess callProcess;

    private final Marker aMarker;

    public CallProcessAction(final ActionExecutionAudit actionExecutionAudit, final Logger log, final Object callProcess) {
        this.callProcess = (CallProcess) callProcess;
        this.actionExecutionAudit = actionExecutionAudit;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker("CallProcess");
    }

    @Override
    public void execute() throws Exception {
        log.info(aMarker, "Call Process Action for {} has been started" , callProcess.getName());
        final String fileRelativePath = callProcess.getSource();
        var targetProcess = callProcess.getTarget();
        var dbSrc = callProcess.getDatasource();
        var sql = callProcess.getValue().replaceAll("\"", "");
        log.info(aMarker, " id#{}, name#{}, calledProcess#{}, calledFile#{}, db=#{}", actionExecutionAudit.getActionId(), callProcess.getName(), targetProcess, fileRelativePath, dbSrc);

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(dbSrc);
        var runContext = new ArrayList<LContext>();
        final Map<String, String> context = actionExecutionAudit.getContext();
        try {
            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(sql);
                formattedQuery.forEach(sqlToExecute -> {
                    log.info(aMarker, "Execution query sql#{} on db=#{}", sqlToExecute, dbSrc);
                    handle.createQuery(sqlToExecute).mapToMap().forEach(stringObjectMap -> {
                        stringObjectMap.forEach((s, o) -> {
                            context.put(s, String.valueOf(o));
                            log.debug("Value " + o + " has been added for " + s);
                        });
                        final LContext lContext = LContext.builder()
                                .inheritedContext(new HashMap<>(context))
                                .lambdaName(actionExecutionAudit.getLambdaName())
                                .parentActionId(actionExecutionAudit.getActionId())
                                .parentActionName(actionExecutionAudit.getActionName())
                                .relativePath(fileRelativePath)
                                .processLoadType(HRequestResolver.LoadType.FILE.name())
                                .pipelineName(callProcess.getTarget())
                                .parentPipelineId(actionExecutionAudit.getPipelineId())
                                .parentPipelineName(actionExecutionAudit.getPipelineName())
                                .rootPipelineId(actionExecutionAudit.getRootPipelineId())
                                .build();
                        runContext.add(lContext);
                    });
                });
            });
        } catch (Exception e) {
            log.error(aMarker, "The Exception occurred ", e);
            throw new HandymanException("Failed to execute call process action for call process "+ callProcess.getName(), e, actionExecutionAudit);
        }

        log.info(aMarker, "Completed name#{}, calledProcess#{}, calledFile#{}, db=#{}", callProcess.getName(), targetProcess, fileRelativePath, dbSrc);

        try {
            final int forkBatchSize = Optional.ofNullable(callProcess.getForkBatchSize()).map(Integer::valueOf).orElse(0);
            if (forkBatchSize != 0) {
                var executor = Executors.newWorkStealingPool(forkBatchSize);
                var counter = new CountDownLatch(runContext.size());
                runContext.forEach(lContext -> {
                    final LambdaCallable lambdaCallable = new LambdaCallable(lContext, counter);
                    executor.submit(lambdaCallable);
                });

                try {
                    counter.await();
                } catch (InterruptedException e) {
                    log.error(aMarker, "The Exception occurred ", e);
                    throw new HandymanException("Call process parallel failed ", e, actionExecutionAudit);
                }

            } else {
                runContext.forEach(lContext -> {
                    final LambdaCallable lambdaCallable = new LambdaCallable(lContext, null);
                    try {
                        final PipelineExecutionAudit start = lambdaCallable.call();
                        context.putAll(start.getContext());
                    } catch (Exception e) {
                        log.error(aMarker, "Failed process {}", lContext, e);
                    }
                });
            }
        } catch (Exception e) {
            log.error(aMarker, "The Exception occurred ", e);
            throw new HandymanException("Failed to execute", e, actionExecutionAudit);
        }

        log.info(aMarker, "Call Process Action for {} has been Completed" , callProcess.getName());
    }


    @Override
    public boolean executeIf() {
        return callProcess.getCondition();
    }
}
