package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ZipBatch;
import in.handyman.raven.util.ExceptionUtil;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ZipBatch"
)
public class ZipBatchAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final ZipBatch zipBatch;

    private final Marker aMarker;
    private final SimpleDateFormat simpleDateTimeFormat = new SimpleDateFormat("MM_dd_yyyy_HH_mm_s");


    public ZipBatchAction(final ActionExecutionAudit action, final Logger log,
                          final Object zipBatch) {
        this.zipBatch = (ZipBatch) zipBatch;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" ZipBatch:" + this.zipBatch.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            log.info(aMarker, "Zip Batch Action for {} has been started", zipBatch.getName());
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(zipBatch.getResourceConn());
            List<String> zipFilePathList = jdbi.withHandle(handle ->
                    handle.createQuery("select zip_file_path from outbound.outbound_zip_file_details where group_id = '" + zipBatch.getGroupId() + "' ")
                            .mapTo(String.class)
                            .collect(Collectors.toList()));
            String outputDirPath = zipBatch.getOutputDir();
            Date currentDate = new Date();
            File outputDirFile = new File(outputDirPath);
            if (outputDirFile.exists()) {
                String zipBatchFolderPath = outputDirPath + File.separator + "ZipBatch" + File.separator + simpleDateTimeFormat.format(currentDate);
                createDirectory(zipBatchFolderPath);
                File zipBatchFolderFile = new File(zipBatchFolderPath);
                zipFilePathList.forEach(zipFilePath -> {
                    File zipFile = new File(zipFilePath);
                    try {
                        log.info("moving zip file {} to folder path {}", zipFile.getName(), zipBatchFolderFile.toPath());
                        Path zipPath = Path.of(zipFile.getPath());
                        Files.copy(zipPath, zipBatchFolderFile.toPath().resolve(zipFile.getName()));
                    } catch (IOException e) {
                        log.error("Failed to copy Zip file");
                        throw new HandymanException("Failed to copy zip file", e, action);
                    }
                });

                if (zipBatchFolderFile.listFiles() == null || Objects.requireNonNull(zipBatchFolderFile.listFiles()).length == 0) {
                    log.info(aMarker, "<-------Folder is Empty------->");
                } else {
                    FileOutputStream fos = new FileOutputStream(zipBatchFolderPath + ".zip");
                    ZipOutputStream zos = new ZipOutputStream(fos);

                    addFolderToZip(String.valueOf(zipBatchFolderFile.toPath()), zos);

                    zos.close();
                    fos.close();
                }
                log.info(aMarker, "<------- Source folder deleted------->" + deleteFolder(zipBatchFolderFile));
            } else {
                log.error("target directory path {} not found", zipBatch.getOutputDir());
                throw new HandymanException("target directory path not found");
            }
            log.info(aMarker, "Zip Batch Action for {} has been completed", zipBatch.getName());
        } catch (Exception e) {
            log.error(aMarker, "Zip Batch Action for {} has failed", zipBatch.getName());
            throw new HandymanException("Zip Batch Action has failed", e, action);
        }

    }

    private static void addFolderToZip(String folderPath, ZipOutputStream zos) {
        try {
            File folder = new File(folderPath);
            File[] files = folder.listFiles();

            if (files != null) {
                for (File file : files) {
                    if (file.isDirectory()) {
                        addFolderToZip(file.getAbsolutePath(), zos);
                    } else {
                        byte[] buffer = new byte[1024];
                        FileInputStream fis = new FileInputStream(file);
                        zos.putNextEntry(new ZipEntry(file.getName()));
                        int length;
                        while ((length = fis.read(buffer)) > 0) {
                            zos.write(buffer, 0, length);
                        }
                        zos.closeEntry();
                        fis.close();
                    }
                }
            }
        } catch (Exception e) {
            throw new HandymanException("Error in adding folder to zip", e);
        }

    }

    private void createDirectory(String folderPath) {
        try {
            Path filepath = Paths.get(folderPath);
            if (!filepath.toFile().exists()) {
                Files.createDirectories(Paths.get(filepath.toUri()));
                log.info("{} Directory Created", filepath);
            } else {
                log.info("{} Directory already exists", filepath);
            }
        } catch (IOException e) {
            log.error(aMarker, "Error in creating the directory {}", ExceptionUtil.toString(e));
            throw new HandymanException("Error in creating directory", e, action);
        }
    }

    private boolean deleteFolder(File folder) {
        if (folder.isDirectory()) {
            // recursively delete all contents of the folder
            File[] files = folder.listFiles();
            if (files != null) {
                for (File file : files) {
                    deleteFolder(file);
                }
            }
        }
        log.info("source batch folder {} deleted", folder.toPath());
        return folder.delete();
    }

    @Override
    public boolean executeIf() throws Exception {
        return zipBatch.getCondition();
    }
}
