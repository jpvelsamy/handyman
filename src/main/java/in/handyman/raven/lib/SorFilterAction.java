package in.handyman.raven.lib;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch.core.SearchResponse;
import co.elastic.clients.json.jackson.JacksonJsonpMapper;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.SorFilter;
import in.handyman.raven.util.ExceptionUtil;
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.nio.reactor.IOReactorConfig;
import org.elasticsearch.client.RestClient;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "SorFilter"
)
public class SorFilterAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final SorFilter sorFilter;

    private final Marker aMarker;
    private final String esUsername;
    private final String esPassword;
    private final String esHostname;
    private final ElasticsearchClient elasticsearchClient;
    private final ObjectMapper mapper = new ObjectMapper();

    public SorFilterAction(final ActionExecutionAudit action, final Logger log,
                           final Object sorFilter) {
        this.sorFilter = (SorFilter) sorFilter;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" SorFilter:" + this.sorFilter.getName());
        this.esUsername = action.getContext().get("es.username");
        this.esPassword = action.getContext().get("es.password");
        this.esHostname = action.getContext().get("es.hostname");
        this.elasticsearchClient = getElasticsearchClient(esUsername, esPassword, esHostname);
    }

    private static ElasticsearchClient getElasticsearchClient(String userName, String password, String hostName) {

        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(userName, password));
        var restClient = RestClient.builder(new HttpHost(hostName, Integer.parseInt("9200"))).setRequestConfigCallback(requestConfigBuilder -> requestConfigBuilder.setConnectTimeout(6000000).setSocketTimeout(6000000)).setHttpClientConfigCallback(httpAsyncClientBuilder -> {
            httpAsyncClientBuilder.setMaxConnTotal(500);
            httpAsyncClientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            httpAsyncClientBuilder.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(10).build());
            return httpAsyncClientBuilder;
        }).build();
        final ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        var transport = new RestClientTransport(restClient, new JacksonJsonpMapper(mapper));
        return new ElasticsearchClient(transport);
    }

    @Override
    public void execute() throws Exception {

        try {
            log.info(aMarker, "Match Phrase query Action for {} has been started" , sorFilter.getName());
            JsonNode sorList = mapper.readTree(sorFilter.getSearchValue());

            List<String> filteredSorList = new ArrayList<String>();
            for (JsonNode synonym : sorList) {
                SearchResponse<Object> filterList = elasticsearchClient
                        .search(s -> s.index("source_of_truth")
                                .query(q -> q.bool(bool -> bool.must(query ->
                                                query.matchPhrase(dd -> dd.field("page_content").query(synonym.asText()))).must(query ->
                                                query.matchPhrase(dd -> dd.field("intics_reference_id").query(sorFilter.getInticsReferenceId()))).must(query ->
                                                query.matchPhrase(dd -> dd.field("file_path").query(sorFilter.getFilePath()))
                                        )
                                )), Object.class);
                long hitsCount = Objects.requireNonNull(filterList.hits().total()).value();
                if (hitsCount > 0) {
                    filteredSorList.add(synonym.asText());
                }
            }
            if (filteredSorList.size() > 0) {
                action.getContext().put(sorFilter.getName() + "_is_present", "true");
            } else {
                action.getContext().put(sorFilter.getName() + "_is_present", "false");
            }

            action.getContext().put(sorFilter.getName() + "_filtered_sorlist", String.valueOf(filteredSorList));

            log.info(aMarker, "Match Phrase Query Action for {} has been completed" , sorFilter.getName());
        } catch (Exception e) {
            action.getContext().put(sorFilter.getName().concat(".error"), "true");
            log.error(aMarker, "The Exception occurred {} ", ExceptionUtil.toString(e));
            throw new HandymanException("Failed to execute sor filter action", e, action);
        }

    }

    @Override
    public boolean executeIf() throws Exception {
        return sorFilter.getCondition();
    }
}
