package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ZipContentList;
import in.handyman.raven.util.ExceptionUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.io.FilenameUtils;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ZipContentList"
)
public class ZipContentListAction implements IActionExecution {
  private final ActionExecutionAudit action;

  private final Logger log;

  private final ZipContentList zipContentList;

  private final Marker aMarker;

  public ZipContentListAction(final ActionExecutionAudit action, final Logger log,
                              final Object zipContentList) {
    this.zipContentList = (ZipContentList) zipContentList;
    this.action = action;
    this.log = log;
    this.aMarker = MarkerFactory.getMarker(" ZipContentList:" + this.zipContentList.getName());
  }

  @Override
  public void execute() throws Exception {
    log.info(aMarker, "Zip File List Action for {} has been started" , zipContentList.getName());
    final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(zipContentList.getResourceConn());
    String zipFilePath = zipContentList.getZipFilePath();
    File zipFile = new File(zipFilePath);


    try (ZipFile zip = new ZipFile(zipFile)) {
      var fileContent = zip.stream().filter(zipEntry -> !zipEntry.isDirectory()).collect(Collectors.toList());
      AtomicInteger i = new AtomicInteger(1);
      fileContent.forEach(zipEntry -> {

        File contentFile = new File(zipFile.getParent() + zipEntry.getName());
        String contentFileName = FilenameUtils.removeExtension(contentFile.getName());
        long fileSize = zipEntry.getSize() / 1024;
        String fileId = String.valueOf(i.getAndIncrement());
        LocalDateTime createdOn = LocalDateTime.ofInstant(
                Instant.ofEpochMilli(zipEntry.getTime()),
                ZoneId.systemDefault());
        String fileExtension = FilenameUtils.getExtension(zipEntry.getName());
        String fileChecksum;
        try {
          fileChecksum = getSHA256Checksum(zipFilePath, zipEntry.getName());
        } catch (IOException | NoSuchAlgorithmException e) {
          log.error(aMarker, "Error in generating checksum for the file {} with the exception {}", contentFile.toPath(), ExceptionUtil.toString(e));
          throw new HandymanException("Error in generating checksum for the file", e, action);
        }

        ZipContentListDetail zipContentListDetail = ZipContentListDetail.builder()
                .fileId(fileId)
                .fileName(contentFileName)
                .fileSize(fileSize)
                .createdOn(createdOn)
                .fileExtension(fileExtension)
                .originId(zipContentList.getOriginId())
                .documentId(zipContentList.getDocumentId())
                .fileChecksum(fileChecksum)
                .build();
        jdbi.useTransaction(handle -> {
          handle.createUpdate("INSERT INTO eoc_response.zip_file_content_list (document_id, file_check_sum, file_extension, file_id, file_name," +
                          "file_size, origin_id, created_on) " +
                          "VALUES( :documentId, :fileChecksum, :fileExtension, :fileId, :fileName, :fileSize, :originId, :createdOn);")
                  .bindBean(zipContentListDetail).execute();
          log.debug(aMarker, "inserted {} into eoc response details"  , zipContentListDetail);
        });
      });
    } catch (Exception e) {
      log.error(aMarker, "Error creating zip file with exception {}", ExceptionUtil.toString(e));
      throw new HandymanException("Error creating zip file", e, action);
    }
    log.info(aMarker, "Zip File List Action for {} has been completed" , zipContentList.getName());

  }

  @Override
  public boolean executeIf() throws Exception {
    return zipContentList.getCondition();
  }

  public static String getSHA256Checksum(String zipFilePath, String entryName)
          throws IOException, NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    try (ZipInputStream zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(zipFilePath)))) {
      ZipEntry entry;
      while ((entry = zis.getNextEntry()) != null) {
        if (entry.getName().equals(entryName)) {
          byte[] buffer = new byte[4096];
          int count;
          while ((count = zis.read(buffer)) != -1) {
            md.update(buffer, 0, count);
          }
          break;
        }
      }
    }
    return bytesToHex(md.digest()).toLowerCase();
  }

  private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();

  private static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j < bytes.length; j++) {
      int v = bytes[j] & 0xFF;
      hexChars[j * 2] = HEX_ARRAY[v >>> 4];
      hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
    }
    return new String(hexChars);
  }

  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public static class ZipContentListDetail {
    private String documentId;
    private String fileChecksum;
    private String fileExtension;
    private String fileId;
    private String fileName;
    private Long fileSize;
    private String originId;
    private LocalDateTime createdOn;
  }
}