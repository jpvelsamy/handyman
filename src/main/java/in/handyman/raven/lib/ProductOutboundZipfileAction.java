package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.ProductOutboundZipFile;
import in.handyman.raven.lib.model.outbound.OutboundInputTableEntity;
import in.handyman.raven.lib.model.outbound.OutboundOutputTableEntity;
import in.handyman.raven.util.CommonQueryUtil;
import in.handyman.raven.util.ExceptionUtil;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.result.ResultIterable;
import org.jdbi.v3.core.statement.Query;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "ProductOutboundZipfile"
)
public class ProductOutboundZipfileAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final ProductOutboundZipFile productOutboundZipfile;

    private final Marker aMarker;

    public ProductOutboundZipfileAction(final ActionExecutionAudit action, final Logger log,
                                        final Object productOutboundZipfile) {
        this.productOutboundZipfile = (ProductOutboundZipFile) productOutboundZipfile;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" ProductOutboundZipfile:" + this.productOutboundZipfile.getName());
    }

    @Override
    public void execute() throws Exception {
        log.info(aMarker, "Asset Info Action for {} has been started", productOutboundZipfile.getName());

        final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(productOutboundZipfile.getResourceConn());
        final List<OutboundInputTableEntity> tableInfos = new ArrayList<>();

        String sourceOutputFolderPath = productOutboundZipfile.getOutputDir();
        jdbi.useTransaction(handle -> {
            final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(productOutboundZipfile.getQuerySet());
            AtomicInteger i = new AtomicInteger(0);
            formattedQuery.forEach(sqlToExecute -> {
                log.info(aMarker, "executing  query {} from index {}", sqlToExecute, i.getAndIncrement());
                Query query = handle.createQuery(sqlToExecute);
                ResultIterable<OutboundInputTableEntity> resultIterable = query.mapToBean(OutboundInputTableEntity.class);
                List<OutboundInputTableEntity> detailList = resultIterable.stream().collect(Collectors.toList());
                tableInfos.addAll(detailList);
                log.info(aMarker, "executed query from index {}", i.get());
            });
        });

        List<OutboundOutputTableEntity> outboundOutputTableEntities = new ArrayList<>();

        tableInfos.forEach(outboundInputTableEntity -> {

            String tenantPathStr = sourceOutputFolderPath + File.separator + outboundInputTableEntity.getTenantId() + File.separator;
            final String originFolderPath = tenantPathStr + "outbound-files" + File.separator + outboundInputTableEntity.getOriginId() + File.separator;
            final String originKvpFolderPath = tenantPathStr + File.separator + "outbound-files" + File.separator + outboundInputTableEntity.getOriginId() + File.separator + "Kvp" + File.separator;
            final String originTableFolderPath = tenantPathStr + File.separator + "outbound-files" + File.separator + outboundInputTableEntity.getOriginId() + File.separator + "Table" + File.separator;
            final String originZipPath = tenantPathStr + File.separator + "zip-files" + File.separator + outboundInputTableEntity.getOriginId() + File.separator;
            String sourceCleanedPdfPath = outboundInputTableEntity.getCleanedPdfPath();
            String sourceOriginPdfPath = outboundInputTableEntity.getOriginPdfPath();
            String sourceJsonString = outboundInputTableEntity.getProductJson();
            String sourceKvpJsonString = outboundInputTableEntity.getKvpResponse();
            String fileNameStr = outboundInputTableEntity.getFileName();

            createFolder(originFolderPath);
            createFolder(originKvpFolderPath);
            //   createFolder(originTableFolderPath);
            createFolder(originZipPath);


            createJsonFile(sourceJsonString, originFolderPath, "productJson");
            createJsonFile(sourceKvpJsonString, originKvpFolderPath, "kvpJson");
            moveFileIntoOrigin(sourceCleanedPdfPath, originFolderPath);
            moveFileIntoOrigin(sourceOriginPdfPath, originFolderPath);
            try {
                String ZipFileNameStr = String.valueOf(outboundInputTableEntity.getRootPipelineId());
                String outboundZipFilePath = createZipFile(originFolderPath, originZipPath, ZipFileNameStr);

                OutboundOutputTableEntity outboundOutputTableEntity = OutboundOutputTableEntity.builder()
                        .originId(outboundInputTableEntity.getOriginId())
                        .groupId(outboundInputTableEntity.getGroupId())
                        .rootPipelineId(outboundInputTableEntity.getRootPipelineId())
                        .processId(outboundInputTableEntity.getProcessId())
                        .cleanedPdfPath(outboundInputTableEntity.getCleanedPdfPath())
                        .originPdfPath(outboundInputTableEntity.getOriginPdfPath())
                        .productJson(outboundInputTableEntity.getProductJson())
                        .kvpResponse(outboundInputTableEntity.getKvpResponse())
                        .tableResponse(outboundInputTableEntity.getTableResponse())
                        .tenantId(outboundInputTableEntity.getTenantId())
                        .zipFilePath(outboundZipFilePath)
                        .fileName(fileNameStr)
                        .stage("PRODUCT_OUTBOUND")
                        .status("COMPLETED")
                        .message("completed for the outbound zip file creation ")
                        .build();
                outboundOutputTableEntities.add(outboundOutputTableEntity);

            } catch (FileNotFoundException e) {
                throw new RuntimeException(e);
            }
            consumerBatch(jdbi, outboundOutputTableEntities);

        });


    }

    public void consumerBatch(final Jdbi jdbi, List<OutboundOutputTableEntity> resultQueue) {
        try {
            resultQueue.forEach(insert -> {
                        jdbi.useTransaction(handle -> {
                            try {
                                handle.createUpdate("INSERT INTO " + productOutboundZipfile.getResultTable() + "(origin_id, root_pipeline_id,group_id,process_id,cleaned_pdf_path,origin_pdf_path,product_json,kvp_response,table_response,tenant_id,zip_file_path,status,stage,message,file_name)" +
                                                "VALUES(:originId,:rootPipelineId,:groupId,:processId,:cleanedPdfPath,:originPdfPath,:productJson,:kvpResponse,:tableResponse,:tenantId,:zipFilePath,:status,:stage,:message,:fileName);")
                                        .bindBean(insert).execute();
                                log.info(aMarker, "inserted {} into outbound zip file details", insert);
                            } catch (Throwable t) {
                                log.error(aMarker, "error inserting result into outbound file details {}", resultQueue, t);
                            }

                        });
                    }
            );
        } catch (Exception e) {
            log.error(aMarker, "error inserting result {}", resultQueue, e);
            HandymanException handymanException = new HandymanException(e);
            HandymanException.insertException("error inserting result" + resultQueue, handymanException, action);
        }
    }


    public void moveFileIntoOrigin(String inputFilePath, String outputDirectory) {
        Path sourcePath = Path.of(inputFilePath);

        File sourceFile = new File(sourcePath.toString());
        // Specify the target directory path
        Path targetDirectory = Path.of(outputDirectory);

        if (!Files.exists(targetDirectory)) {
            createFolder(targetDirectory.toString());
        }

        boolean isFileExists = sourceFile.exists();
        if (isFileExists) {
            try {
                // Use Files.move() to move the file to the target directory
                Path targetPath = targetDirectory.resolve(sourcePath.getFileName());
                Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);

                log.info("File moved from {} to {}", inputFilePath, outputDirectory);
            } catch (IOException e) {
                log.error("File moved failed for {} to {}", inputFilePath, outputDirectory);
                HandymanException handymanException = new HandymanException(e);
                HandymanException.insertException("failed in moving the file", handymanException, action);
                throw new HandymanException("Error in execute method for ner adapter", e, action);
            }
        } else {
            log.info("File not found from {} to {}", inputFilePath, outputDirectory);
        }
    }

    public void createFolder(String directoryPath) {

        File directoryFile = new File(directoryPath);

        if (!directoryFile.exists()) {
            if (directoryFile.mkdirs()) {
                log.info("Origin Directory created {}", directoryPath);

            } else {
                log.info("Origin Directory creation failed {}", directoryPath);
            }
        } else {
            log.info("Origin Directory already present {}", directoryPath);
        }

    }

    public String createZipFile(String inputFolder, String outputZipPath, String fileName) throws FileNotFoundException {


        try {

            if (!Files.exists(Paths.get(inputFolder)))
                log.info(aMarker, "{} inputFolder Folder not found", inputFolder);
            FileOutputStream fos = new FileOutputStream(outputZipPath + File.separator + fileName + ".zip");
            ZipOutputStream zipOut = new ZipOutputStream(fos);
            File fileToZip = new File(inputFolder);
            zipFile(fileToZip, fileToZip.getName(), zipOut);
            zipOut.close();
            fos.close();
        } catch (Exception e) {
            log.error(aMarker, "Error in execute method in create zip action {}", ExceptionUtil.toString(e));
            throw new HandymanException("Error in execute method in create zip action", e, action);
        }
        return outputZipPath;
    }

    public void zipFile(File fileToZip, String fileName, ZipOutputStream zipOut) {
        try {
            if (fileToZip.isHidden()) {
                return;
            }
            if (fileToZip.isDirectory()) {
                if (fileName.endsWith("/")) {
                    zipOut.putNextEntry(new ZipEntry(fileName));
                    zipOut.closeEntry();
                } else {
                    zipOut.putNextEntry(new ZipEntry(fileName + "/"));
                    zipOut.closeEntry();
                }
                File[] children = fileToZip.listFiles();
                if (children != null && children.length > 0) {
                    for (File childFile : children) {
                        zipFile(childFile, fileName + "/" + childFile.getName(), zipOut);
                    }
                    return;
                }
            }
            FileInputStream fis = new FileInputStream(fileToZip);
            ZipEntry zipEntry = new ZipEntry(fileName);
            zipOut.putNextEntry(zipEntry);
            byte[] bytes = new byte[1024];
            int length;
            while ((length = fis.read(bytes)) >= 0) {
                zipOut.write(bytes, 0, length);
            }
            fis.close();
            log.info(aMarker, "Created zip {} and saved in the {} directory", fileToZip.getName(), fileToZip.getAbsolutePath());
        } catch (Exception e) {
            log.error(aMarker, "Error in zip file generation {}", ExceptionUtil.toString(e));
            throw new HandymanException("Error in zip file generation", e, action);
        }

    }

    public void createJsonFile(String jsonString, String jsonPath, String jsonName) {

        String filePath = jsonPath + File.separator + jsonName + ".json";

        Path path = Paths.get(jsonPath);
        if (!Files.exists(path)) {
            createFolder(path.toString());
        }

        try (FileWriter fileWriter = new FileWriter(filePath)) {
            fileWriter.write(jsonString);
            log.info("json response coverted to json file {}", jsonString);
        } catch (IOException e) {
            log.info("json file creation failed {}", filePath);

        }

    }


    @Override
    public boolean executeIf() throws Exception {
        return productOutboundZipfile.getCondition();
    }
}
